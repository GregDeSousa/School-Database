//import sun.invoke.empty.Empty;

import java.io.*;
import java.util.Arrays;

public class Main {

    public static void main(String[] args) throws DatabaseException {
        task1();              //testing base treap structure and boundaries ---complete----
        task2();              //added functionality to given database ---complete----
        task3();                //testing base DB structure and boundaries ---complete---
    }

    public static void task1() throws DatabaseException {
        /*
         * You are not given a Main for this task, because we want you to figure out how
         * to do it for yourself.
         *
         * You are provided with a validTreap() function which will print out valid or
         * invalid for a passed in Treap.
         *
         * Use this function to make sure that your heaps follow the rules set by the
         * Assignment.
         *
         * Tip : Create a Main that inserts / deletes a lot of elements and call
         * validTreap after every step
         */

        System.out.println("empty treap testing");
        Treap<Integer> empty = new Treap<>();
        //empty delete
        System.out.println("empty remove 10: ");
        if(empty.remove(10) == null) System.out.println("\u001B[32m" + "Empty remove success" + "\u001B[0m");
        else System.out.println("\u001B[31m" + "Empty remove unsuccessful" + "\u001B[0m");


        //empty access
        System.out.println("empty access 10: ");
        if(empty.access(10) == null) System.out.println("\u001B[32m" + "Empty access success" + "\u001B[0m");
        else System.out.println("\u001B[31m" + "Empty access unsuccessful" + "\u001B[0m");

        System.out.println("treap testing");
        Treap<Integer> t = new Treap<>();

        for(int i = 0; i < 100; i+=10){
            System.out.println("inserting: " + i);
            t.insert(i);
            System.out.print("Is treap valid after inserting " + i+ " : " + validTreap(t));
        }
        System.out.println("inserting: " + 5);
        t.insert(5);
        System.out.print("Is treap valid after inserting 5: " + validTreap(t));

        System.out.println("inserting: " + 12);
        t.insert(12);
        System.out.print("Is treap valid after inserting 12: " + validTreap(t));

        System.out.println("inserting: " + 99);
        t.insert(99);
        System.out.print("Is treap valid after inserting 99: " + validTreap(t));

        System.out.println("inserting: " + 102);
        t.insert(102);
        System.out.print("Is treap valid after inserting 102: " + validTreap(t));

        System.out.println("inserting: " + 1);
        t.insert(1);
        System.out.print("Is treap valid:  after inserting 1: " + validTreap(t));

        System.out.println("Final treap");
        System.out.println(t);



        try{
            System.out.println("insert dupicate 99: ");
            t.insert(99);
            System.out.print("Is treap valid after inserting duplicate 99: ");
            System.out.print(validTreap(t));
            System.out.println("\u001B[31m" + "insert duplicate not caught\"" + "\u001B[0m");
        } catch (Exception e) {
            System.out.println("\u001B[32m" + "insert duplicate caught" + "\u001B[0m");
        }

        System.out.println("Remove treap testing: ");
        System.out.println("Removing: " + 60);
        Node<Integer> tr = t.remove(60);
        if(tr != null) System.out.println("\u001B[32m" + "60/root remove success" + tr + "\u001B[0m");
        else System.out.println("\u001B[31m" + "60/root remove unsuccessful" + "\u001B[0m");
        System.out.print("Is treap valid after removing 60(root): " + validTreap(t));
        System.out.println(t);
        System.out.println();
        System.out.println("Removing: " + 12);
        tr = t.remove(12);
        if(tr != null) System.out.println("\u001B[32m" + "12/non-leaf remove success" + tr+ "\u001B[0m");
        else System.out.println("\u001B[31m" + "12/non-leaf remove unsuccessful" + "\u001B[0m");
        System.out.print("Is treap valid after removing 12(non-leaf): " + validTreap(t));
        System.out.println(t);

        System.out.println();
        System.out.println("Removing: " + 50);
        tr = t.remove(50);
        if(tr != null) System.out.println("\u001B[32m" + "50/leaf remove success" + tr + "\u001B[0m");
        else System.out.println("\u001B[31m" + "50/leaf remove unsuccessful" + "\u001B[0m");
        System.out.print("Is treap valid after removing 50(leaf): " + validTreap(t));
        System.out.println(t);
        System.out.println();

        System.out.println("Removing non-existent: " + 99999);
        tr = t.remove(99999);
        if(tr == null) System.out.println("\u001B[32m" + "99999 not found" + "\u001B[0m");
        else System.out.println("\u001B[31m" + "99999 found: " + tr + "\u001B[0m");
        System.out.print("Is treap valid after removing 99999(non-existent): " + validTreap(t));
        System.out.println(t);
        System.out.println();


        System.out.println("Access testing");

        System.out.println("Accessing 10(root) ");
        Node<Integer> accessor = t.access(10);
        if(accessor != null) System.out.println("\u001B[32m" + "10 found: " +  accessor + "\u001B[0m");
        else System.out.println("\u001B[31m" + "10 not found" + "\u001B[0m");
        System.out.print("Is treap valid after accessing 10: " + validTreap(t));
        System.out.println(t);
        System.out.println();

        System.out.println("Accessing 99(non-leaf) ");
        accessor = t.access(99);
        if(accessor != null) System.out.println("\u001B[32m" + "99 found: " +  accessor + "\u001B[0m");
        else System.out.println("\u001B[31m" + "99 not found" + "\u001B[0m");
        System.out.print("Is treap valid after accessing 99: " + validTreap(t));
        System.out.println(t);
        System.out.println();

        System.out.println("Accessing 102(leaf) ");
        accessor = t.access(102);
        if(accessor != null) System.out.println("\u001B[32m" + "102 found: " +  accessor + "\u001B[0m");
        else System.out.println("\u001B[31m" + "102 not found" + "\u001B[0m");
        System.out.print("Is treap valid after accessing 102: " + validTreap(t));
        System.out.println(t);
        System.out.println();

        System.out.println("Acceessing non-existent: " + 99999);
        Node<Integer> accessor1 = t.access(99999);
        if(accessor1 == null) System.out.println("\u001B[32m" + "99999 not found" + "\u001B[0m");
        else System.out.println("\u001B[31m" + "99999 found" + "\u001B[0m");
        System.out.print("Is treap valid after accessing non-existent 99999: " + validTreap(t));
        System.out.println(t);
        System.out.println();

    }

    public static void task2() throws DatabaseException {
        /*
         * Note that we also want you to create your own main for this task.
         *
         * It takes a while to set the DB up, so an example is given below, feel free to
         * change it to test the rest of the functions
         */


//        PrintStream stdout = System.out;
//        File file = new File("sample.txt");
//        PrintStream stream = new PrintStream(file);
//        System.setOut(stream);

        String[] columns = { "Module Code", "Description", "Credits", "Year", "Session" };
        Database db = new Database(columns, 100);

        String[][] modules = {
                { "LST110", "Language and study skills 110", "6", "1", "Sem 1" },
                { "WTW124", "Mathematics 124", "16", "1", "Sem 2" },
                { "UP0102", "Academic orientation 102", "0", "1", "Year" },
                { "WTW114", "Calculus 114", "16", "1", "Sem 1" },
                { "WTW123", "Numerical analysis 123", "8", "1", "Sem 2" },
                { "PHY114", "First course in physics 114", "16", "1", "Sem 1" },
                { "PHY124", "First course in physics 124", "16", "1", "Sem 2" },
                { "AIM102", "Academic information management 102", "6", "1", "Sem 2" },
                { "COS122", "Operating systems 122", "16", "1", "Sem 2" },
                { "COS132", "Imperative programming 132", "16", "1", "Sem 1" },
                { "COS110", "Program design: Introduction 110", "16", "1", "Sem 2" },
                { "COS151", "Introduction to computer science 151", "8", "1", "Sem 1" },
                { "COS212", "Data structures and algorithms 212", "16", "2", "Sem 1" },
                { "COS226", "Concurrent systems 226", "16", "2", "Sem 2" },
                { "COS284", "Computer organisation and architecture 284", "16", "2", "Sem 2" },
                { "COS210", "Theoretical computer science 210", "8", "2", "Sem 1" },
                { "WTW248", "Vector analysis 248", "12", "2", "Sem 2" },
                { "PHY255", "Waves, thermodynamics and modem physics 255", "24", "2", "Sem 1" },
                { "PHY263", "General physics 263", "24", "2", "Sem 2" },
                { "WTW211", "Linear algebra 211", "12", "2", "Sem 1" },
                { "WTW218", "Calculus 218", "12", "2", "Sem 1" },
                { "WTW220", "Analysis 220", "12", "2", "Sem 2" },
                { "COS314", "Artificial intelligence 314", "18", "3", "Sem 1" },
                { "COS330", "Computer security and ethics 330", "18", "3", "Sem 2" },
                { "COS333", "Programming languages 333", "18", "3", "Sem 2" },
                { "COS344", "Computer graphics 344", "18", "3", "Sem 1" },
                { "PHY310", "Particle and astroparticle physics 310", "18", "3", "Sem 2" },
                { "PHY356", "Electronics, electromagnetism and quantum mechanics 356", "36", "3", "Sem 1" },
                { "PHY364", "Statistical mechanics, solid state physics and modelling 364", "36", "3", "Sem 2" },
                { "COS711", "Artificial Intelligence (II) 711", "15", "4", "Sem 2" },
                { "FSK700", "Physics 700", "135", "4", "Year" }
        };

        try {
            for (String[] mod : modules) {
                db.insert(mod);
            }

            db.generateIndexAll();
        } catch (DatabaseException e) {
            System.out.println("Error: " + e);
        }

        for (String[] row : db.database) {
            if (row[0] != null) {
                int c = 0;
                for (String s : row) {
                    if (c++ == 1) {
                        System.out.print(String.format("%1$-75s", s));
                    } else {
                        System.out.print(s + "\t");
                    }
                }
                System.out.println();
            }
        }

        //-------------------
        //random tests
        //---------------
//        Treap<Cell>[] temp2 = db.generateIndexAll();
//        System.out.println("testing generation for empty and NOT NULL treaps");
//        for(int i = 0; i< columns.length; i++){
//            System.out.println(columns[i] + ": ");
//            System.out.println(temp2[i]);
//            System.out.println(db.indexes[i]);
//            System.out.print("Is treap valid: " + validTreap(temp2[i]));
//        }

//        String[][] temp = db.findAllWhere("Module Code", "COS212");
//        String[] temp1 = db.findFirstWhere("Module Code", "PHY174");
//        System.out.println(Arrays.toString(temp));

//        db.indexes[0].access()

//        System.out.println("Accessing 10(root) ");
//        Cell t = new Cell();
//        t.databaseRow = -1;
//        t.value = "PHY3579";
//        System.out.println(db.indexes[0]);
//        Node<Cell> accessor = db.indexes[0].access(t);
//        System.out.println(db.indexes[0]);
//
//        db.indexes[0].insert(accessor.data);
//        if(accessor != null) System.out.println("\u001B[32m" + "PHY356 found: " +  accessor + "\u001B[0m");
//        else System.out.println("\u001B[31m" + "PHY356 not found" + "\u001B[0m");
//        System.out.print("Is treap valid: " + validTreap(accessor));
//        System.out.println(accessor.priority);
//        System.out.println();
//        System.out.println(db.indexes[0]);
//        System.out.println(db.indexes[1]);
//        System.out.print(validTreap(db.indexes[0]));
//        System.out.print(validTreap(db.indexes[1]));
//
        try{
            System.out.println("Remove first Where Module Code is COS344");
            System.out.println("--------------");
            System.out.println("String returned: " + Arrays.toString(db.removeFirstWhere("Module Code", "COS344")));
            System.out.println(db.indexes[0]);
            System.out.print("Is treap valid after removing : COS344 ->" + validTreap(db.indexes[0]));
            System.out.println(db.indexes[1]);
            System.out.print("Is treap valid after removing : COS344 ->" + validTreap(db.indexes[1]));
            System.out.println();
            if(db.findFirstWhere("Module Code", "COS344").length == 0){
                System.out.println("\u001B[32m" + "COS344 deleted " + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "error deleting COS344 or error in FindFirstWhere " + "\u001B[0m");

            }

        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }
        System.out.println("--------------");

        try{
            System.out.println("Attempting to findAllWhere Session is Sem 1");
            String[][] finder = db.findAllWhere("Session", "Sem 1");
            boolean correct = true;
            for(String[] str: finder){
                System.out.println(Arrays.toString(str));
                if(!Arrays.toString(str).endsWith("Sem 1]")) correct = false;
            }
            if(correct) System.out.println("\u001B[32m" + "Correct records found" + "\u001B[0m");
            else System.out.println("\u001B[31m" + "Incorrect records found" + "\u001B[0m");
//            smalldb2.updateFirstWhere("Session", "Sem 2", "Year");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }
        System.out.println("--------------");

        try{
            System.out.println("Attempting to countOccurences of Session as Sem 1");
            int session1 = db.countOccurences("Session", "Sem 1");
            if(session1 == 12) System.out.println("\u001B[32m" + "countOccurences of Session as Sem 1-> " + session1 + "\u001B[0m");
            else System.out.println("\u001B[31m" + "countOccurences of Session as Sem 1->" + session1 + "\u001B[0m");
            System.out.println("--------------");
            System.out.println("Attempting to countOccurences of Session as Sem 2");
            session1 = db.countOccurences("Session", "Sem 2");
            if(session1 == 16) System.out.println("\u001B[32m" + "countOccurences of Session as Sem 2-> " + session1 + "\u001B[0m");
            else System.out.println("\u001B[31m" + "countOccurences of Session as Sem 2->" + session1 + "\u001B[0m");

            System.out.println("--------------");
            System.out.println("Attempting to countOccurences of Module Code as WTW 211");
            session1 = db.countOccurences("Module Code", "WTW211");
            if(session1 == 1) System.out.println("\u001B[32m" + "countOccurences of Module Code as WTW211-> " + session1 + "\u001B[0m");
            else System.out.println("\u001B[31m" + "countOccurences of Module Code as WTW211->" + session1 + "\u001B[0m");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }

    }

    public static void task3() throws DatabaseException {
        System.out.println("----------------");
        System.out.println("Database testing");
        System.out.println("----------------");


        System.out.println("Empty Database testing");
        String[] Emptycolumns = { "Module Code", "Description","Session" };
        Database Emptydb = new Database(Emptycolumns, 1);
        String[][] Emptymodules = {
                { "LST110", "Language and study skills 110","Sem 1" },
                { "WTW124", "Mathematics 124", "Sem 2" },
                { "UP0102", "Academic orientation 102", "Year" },
                { "WTW114", "Calculus 114", "Sem 1" },
                { "WTW123", "Numerical analysis 123", "Sem 2" }
        };
        String[] incorrectSize = {"LST222", "Sem 1"};
        String[] EmptyString = {};


        System.out.println("Empty Database insert testing");

        System.out.println("incorrect row insert testing");

        try{
            Emptydb.insert(incorrectSize);
            System.out.println("\u001B[31m" + "incorrect insert not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "Incorrect insert caught: " + e +"\u001B[0m");
        }

        System.out.println("empty row insert testing");

        try{
            Emptydb.insert(EmptyString);
            System.out.println("\u001B[31m" + "empty insert not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty insert caught: " + e +"\u001B[0m");
        }

        System.out.println("empty removeFirstWhere testing");
        System.out.println("empty removeFirstWhere with wrong column name");
        try{
            Emptydb.removeFirstWhere("module code", "WTW114");
            System.out.println("\u001B[31m" + "wrong column name removeFirstWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name removeFirstWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty removeFirstWhere");
        try{
            String[] emptyrem = Emptydb.removeFirstWhere("Module Code", "WTW114");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty removeFirstWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty removeFirstWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty removeFirstWhere caught: " + e + "\u001B[0m");
        }

        System.out.println("empty removeAllWhere testing");
        System.out.println("empty removeAllWhere with wrong column name");
        try{
            Emptydb.removeAllWhere("session", "Year");
            System.out.println("\u001B[31m" + "wrong column name removeAllWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name removeAllWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty removeAllWhere");
        try{
            String[][] emptyrem = Emptydb.removeAllWhere("Session", "Sen 1");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty removeAllWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty removeAllWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty removeAllWhere caught: " + e + "\u001B[0m");
        }

        System.out.println("empty findFirstWhere testing");
        System.out.println("empty findFirstWhere with wrong column name");
        try{
            Emptydb.findFirstWhere("session", "Year");
            System.out.println("\u001B[31m" + "wrong column name findFirstWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name findFirstWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty findFirstWhere");
        try{
            String[] emptyrem = Emptydb.findFirstWhere("Session", "Sen 1");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty findFirstWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty findFirstWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty findFirstWhere caught: " + e + "\u001B[0m");
        }


        System.out.println("empty findAllWhere testing");
        System.out.println("empty findAllWhere with wrong column name");
        try{
            Emptydb.findAllWhere("session", "Year");
            System.out.println("\u001B[31m" + "wrong column name findAllWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name findAllWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty findAllWhere");
        try{
            String[][] emptyrem = Emptydb.findAllWhere("Session", "Sen 1");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty findAllWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty findAllWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty findAllWhere caught: " + e + "\u001B[0m");
        }


        System.out.println("empty updateFirstWhere testing");
        System.out.println("empty updateFirstWhere with wrong column name");
        try{
            Emptydb.updateFirstWhere("session","Sem 1", "Year");
            System.out.println("\u001B[31m" + "wrong column name updateFirstWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name updateFirstWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty updateFirstWhere");
        try{
            String[] emptyrem = Emptydb.updateFirstWhere("Session", "Sem 1","Year");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty updateFirstWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty updateFirstWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty updateFirstWhere caught: " + e + "\u001B[0m");
        }

        System.out.println("empty updateAllWhere testing");
        System.out.println("empty updateAllWhere with wrong column name");
        try{
            Emptydb.updateAllWhere("session","Sem 1" ,"Year");
            System.out.println("\u001B[31m" + "wrong column name updateAllWhere not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name updateAllWhere caught: " +e + "\u001B[0m");
        }
        System.out.println("empty updateAllWhere");
        try{
            String[][] emptyrem = Emptydb.updateAllWhere("Session", "Sem 1","Year");
            if(emptyrem.length == 0){
                System.out.println("\u001B[32m" + "empty updateAllWhere returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty updateAllWhere not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty updateAllWhere caught: " + e + "\u001B[0m");
        }

        System.out.println("empty generateIndexOn testing");
        System.out.println("empty generateIndexOn with wrong column name");
        try{
            Emptydb.generateIndexOn("session");
            System.out.println("\u001B[31m" + "wrong column name generateIndexOn not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name generateIndexOn caught: " +e + "\u001B[0m");
        }
        System.out.println("empty generateIndexOn");
        try{
            Treap<Cell> emptyrem = Emptydb.generateIndexOn("Session");
            if(emptyrem.root == null){
                System.out.println("\u001B[32m" + "empty generateIndexOn returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty generateIndexOn not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty generateIndexOn caught: " + e + "\u001B[0m");
        }

        System.out.println("empty generateIndexAll testing");
        System.out.println("empty generateIndexAll");
        try{
            Treap<Cell>[] emptyrem = Emptydb.generateIndexAll();
            if(emptyrem[0].root == null){
                System.out.println("\u001B[32m" + "empty generateIndexAll returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "empty generateIndexAll not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty generateIndexAll caught: " + e + "\u001B[0m");
        }

        System.out.println("empty countOccurences testing");
        System.out.println("empty countOccurences with wrong column name");
        try{
            Emptydb.countOccurences("session", "Year");
            System.out.println("\u001B[31m" + "wrong column name countOccurences not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name countOccurences caught: " +e + "\u001B[0m");
        }
        System.out.println("empty countOccurences");
        try{
            int emptyrem = Emptydb.countOccurences("Session", "Year");
            if(emptyrem == 0){
                System.out.println("\u001B[32m" + "no countOccurences returned" + "\u001B[0m");
            }else{
                System.out.println("\u001B[31m" + "no countOccurences not returned" + "\u001B[0m");
            }
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "empty countOccurences caught: " + e + "\u001B[0m");
        }

        System.out.println();
        System.out.println("------------");
        System.out.println("DB testing");
        System.out.println("------------");

        System.out.println();


        String[] smallColumns = { "Module Code", "Description","Session" };
        Database smalldb1 = new Database(smallColumns, 1);
        String[][] smallmodules = {
                { "LST110", "Language and study skills 110","Sem 1" },
                { "WTW124", "Mathematics 124", "Sem 2" },
                { "UP0102", "Academic orientation 102", "Year" },
                { "WTW114", "Calculus 114", "Sem 1" },
                { "WTW123", "Numerical analysis 123", "Sem 2" }
        };
        String[] smallincorrectSize = {"LST222", "Sem 1"};
        String[] smallduplicate = {"WTW114","Calculus 114", "Sem 1"};

        String[] smallEmptyString = {};

        System.out.println("insert testing");
        System.out.println("------------");

        System.out.println("insert database full test");
        try {
            for (String[] mod : smallmodules) {
                smalldb1.insert(mod);
            }
            System.out.println("\u001B[31m" + "database full exception not caught" + "\u001B[0m");
//            db.generateIndexAll();
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "database full exception caught: " + e + "\u001B[0m");
//            System.out.println("Error: " + e);
        }

        Database smalldb2 = new Database(smallColumns, 20);
        System.out.println("insert database test");
        try {
            for (String[] mod : smallmodules) {
                smalldb2.insert(mod);
            }
            System.out.println("\u001B[32m" + "database succesfully populated" + "\u001B[0m");
//            db.generateIndexAll();
        } catch (DatabaseException e) {
            System.out.println("\u001B[31m" + "database insert error: " + e + "\u001B[0m");
//            System.out.println("Error: " + e);
        }

        System.out.println("insert database generateIndexOn test");
        System.out.println("insert database generateIndexOn incorrect name test");

        try{
            smalldb2.generateIndexOn("session");
            System.out.println("\u001B[31m" + "wrong column name generateIndexOn not caught\"" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "wrong column name generateIndexOn caught: " +e + "\u001B[0m");
        }

        System.out.println("insert database generateIndexOn Normal test");

        try{
            smalldb2.generateIndexOn("Module Code");
            System.out.println("\u001B[32m" + "Module Code index generated" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[31m" + "Module Code index generation error: " +e + "\u001B[0m");
        }
        System.out.println(smalldb2.indexes[0]);
        System.out.print("Is treap valid after generating indexOn Module code: " + validTreap(smalldb2.indexes[0]));

        System.out.println("insert exception database generateIndexOn test");
        try{
            smalldb2.insert(smallduplicate);
            System.out.println("\u001B[31m" + "Duplicate inserted" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[32m" + "Duplicate exception caught: " +e + "\u001B[0m");
        }
        System.out.println("insert database generateAllOn Normal test");

        try{
            smalldb2.generateIndexAll();
            System.out.println("\u001B[32m" + "all indexes generated" + "\u001B[0m");
        } catch (DatabaseException e) {
            System.out.println("\u001B[31m" + "All index generation error: " +e + "\u001B[0m");
        }
        System.out.println(smalldb2.indexes[0]);
        System.out.print("Is treap valid after generateIndexAll: " + validTreap(smalldb2.indexes[0]));
        System.out.println(smalldb2.indexes[1]);
        System.out.print("Is treap valid after generateIndexAll: " + validTreap(smalldb2.indexes[1]));

        System.out.println("---------------");
        System.out.println("Testing Find & Update");
        System.out.println("---------------");


        try{
            System.out.println("Attempting to findfirstWhere Session is Year: [UP0102, Academic orientation 102, Year]");
            String[] finder = smalldb2.findFirstWhere("Session", "Year");
            System.out.println(Arrays.toString(finder));
            String correct = "[UP0102, Academic orientation 102, Year]";
            if(correct.equals(Arrays.toString(finder))) System.out.println("\u001B[32m" + "Correct record found" + "\u001B[0m");
            else System.out.println("\u001B[31m" + "Incorrect record found" + "\u001B[0m");
//            smalldb2.updateFirstWhere("Session", "Sem 2", "Year");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }

        try{
            System.out.println("Attempting to findAllWhere Session is Sem 1: [LST110, Language and study skills 110, Sem 1], [WTW114, Calculus 114, Sem 1]");
            String[][] finder = smalldb2.findAllWhere("Session", "Sem 1");
            String[][] correct = {
                    { "LST110", "Language and study skills 110","Sem 1" },
                    { "WTW114", "Calculus 114", "Sem 1" }
            };

            for(String[] str: finder){
                System.out.println(Arrays.toString(str));
            }
            if(Arrays.deepEquals(correct, finder)) System.out.println("\u001B[32m" + "Correct records found" + "\u001B[0m");
            else System.out.println("\u001B[31m" + "Incorrect records found" + "\u001B[0m");
//            smalldb2.updateFirstWhere("Session", "Sem 2", "Year");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }

        try{
            System.out.println("Attempting to updatefirstWhere Session is Year to Sem 2: [UP0102, Academic orientation 102, Year] -> [UP0102, Academic orientation 102, Sem 2]");
            String[] finder = smalldb2.updateFirstWhere("Session","Year", "Sem 2");
            System.out.println(Arrays.toString(finder));
            String correct = "[UP0102, Academic orientation 102, Sem 2]";
            if(correct.equals(Arrays.toString(finder))) System.out.println("\u001B[32m" + "Correct record found" + "\u001B[0m");
            else System.out.println("\u001B[31m" + "Incorrect record Updated" + "\u001B[0m");
            smalldb2.updateFirstWhere("Session", "Sem 2", "Year");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }

        try{
            System.out.println("Attempting to UpdateAllWhere Session is Sem 1 to Year: [LST110, Language and study skills 110, Sem 1], [WTW114, Calculus 114, Sem 1] -> [LST110, Language and study skills 110, Year], [WTW114, Calculus 114, Year]");
            String[][] finder = smalldb2.updateAllWhere("Session", "Sem 1", "Year");
            for(String[] str: finder){
                System.out.println(Arrays.toString(str));
            }
            String[][] correct = {
                    { "LST110", "Language and study skills 110","Year" },
                    { "WTW114", "Calculus 114", "Year" }
            };
            if(Arrays.deepEquals(correct, finder)) System.out.println("\u001B[32m" + "Correct records updated" + "\u001B[0m");
            else System.out.println("\u001B[31m" + "Incorrect record found" + "\u001B[0m");
            smalldb2.updateFirstWhere("Session", "Sem 2", "Year");
        }catch(Exception e){
            System.out.println("\u001B[31m" + "unexpected exception: " + e + "\u001B[0m");
        }

        System.out.println("---------------");
        System.out.println("removing all modules");

        for(int i = 0; i < smallmodules.length; i++){
            System.out.println("--------------");
            System.out.println("Removing: " + smallmodules[i][0]);
            System.out.println("String returned: " + Arrays.toString(smalldb2.removeFirstWhere("Module Code", smallmodules[i][0])));
            System.out.println(smalldb2.indexes[0]);
            System.out.print("Is treap valid after removing : " + smallmodules[i][0] + "->" + validTreap(smalldb2.indexes[0]));
            System.out.println(smalldb2.indexes[1]);
            System.out.print("Is treap valid after removing : " + smallmodules[i][0] + "->" + validTreap(smalldb2.indexes[1]));
            System.out.println();


        }


    }

    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_RED = "\u001B[31m";
    public static final String ANSI_GREEN = "\u001B[32m";

    public static <T extends Comparable<T>> String validTreap(Treap<T> t) {
        return (validTreap(t.root) ? ANSI_GREEN + "Valid\n" + ANSI_RESET : ANSI_RED + "Invalid\n" + ANSI_RESET);
    }

    public static <T extends Comparable<T>> boolean validTreap(Node<T> n) {
        if (n == null) {
            return true;
        }

        if (n.left != null && (n.left.priority > n.priority || n.getData().compareTo(n.left.getData()) < 0)) {
            return false;
        }

        if (n.right != null && (n.right.priority > n.priority || n.getData().compareTo(n.right.getData()) > 0)) {
            return false;
        }

        if (!validTreap(n.left)) {
            return false;
        }

        if (!validTreap(n.right)) {
            return false;
        }

        return true;
    }

//    private static long checkMatch(){
//        Path path1 = Paths.get("out.txt");
//        Path path2 = Paths.get("sample.txt");
//        try (BufferedReader bf1 = Files.newBufferedReader(path1);
//             BufferedReader bf2 = Files.newBufferedReader(path2)) {
//
//            long lineNumber = 1;
//            String line1 = "", line2 = "";
//            while ((line1 = bf1.readLine()) != null) {
//                line2 = bf2.readLine();
//                if (line2 == null || !line1.equals(line2)) {
//                    return lineNumber;
//                }
//                lineNumber++;
//            }
//            if (bf2.readLine() == null) {
//                return -1;
//            }
//            else {
//                return lineNumber;
//            }
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
//        return 0;
//    }
}


/*     Expected output:
Task 1
empty treap testing
empty remove 10:
Empty remove success
empty access 10:
Empty access success
treap testing
inserting: 0
Is treap valid after inserting 0 : Valid
inserting: 10
Is treap valid after inserting 10 : Valid
inserting: 20
Is treap valid after inserting 20 : Valid
inserting: 30
Is treap valid after inserting 30 : Valid
inserting: 40
Is treap valid after inserting 40 : Valid
inserting: 50
Is treap valid after inserting 50 : Valid
inserting: 60
Is treap valid after inserting 60 : Valid
inserting: 70
Is treap valid after inserting 70 : Valid
inserting: 80
Is treap valid after inserting 80 : Valid
inserting: 90
Is treap valid after inserting 90 : Valid
inserting: 5
Is treap valid after inserting 5: Valid
inserting: 12
Is treap valid after inserting 12: Valid
inserting: 99
Is treap valid after inserting 99: Valid
inserting: 102
Is treap valid after inserting 102: Valid
inserting: 1
Is treap valid:  after inserting 1: Valid
Final treap
60[114]
├(L)─ 10[97]
|    ├(L)─ 0[84]
|    |    └(R)─ 1[62]
|    |       └(R)─ 5[46]
|    └(R)─ 12[62]
|       └(R)─ 20[58]
|          └(R)─ 40[49]
|             ├(L)─ 30[32]
|             └(R)─ 50[27]
└(R)─ 80[95]
   ├(L)─ 70[54]
   └(R)─ 99[60]
      ├(L)─ 90[55]
      └(R)─ 102[2]

insert dupicate 99:
insert duplicate caught
Remove treap testing:
Removing: 60
60/root remove success60[114]
Is treap valid after removing 60(root): Valid
10[97]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 12[62]
   |    └(R)─ 20[58]
   |       └(R)─ 70[54]
   |          └(L)─ 40[49]
   |               ├(L)─ 30[32]
   |               └(R)─ 50[27]
   └(R)─ 99[61]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Removing: 12
12/non-leaf remove success12[62]
Is treap valid after removing 12(non-leaf): Valid
10[97]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            ├(L)─ 30[32]
   |            └(R)─ 50[27]
   └(R)─ 99[61]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Removing: 50
50/leaf remove success50[27]
Is treap valid after removing 50(leaf): Valid
10[97]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[61]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Removing non-existent: 99999
99999 not found
Is treap valid after removing 99999(non-existent): Valid
10[97]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[61]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Access testing
Accessing 10(root)
10 found: 10[98]
Is treap valid after accessing 10: Valid
10[98]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[61]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Accessing 99(non-leaf)
99 found: 99[62]
Is treap valid after accessing 99: Valid
10[98]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[62]
      ├(L)─ 90[55]
      └(R)─ 102[2]


Accessing 102(leaf)
102 found: 102[3]
Is treap valid after accessing 102: Valid
10[98]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[62]
      ├(L)─ 90[55]
      └(R)─ 102[3]


Acceessing non-existent: 99999
99999 not found
Is treap valid after accessing non-existent 99999: Valid
10[98]
├(L)─ 0[84]
|    └(R)─ 1[62]
|       └(R)─ 5[46]
└(R)─ 80[95]
   ├(L)─ 20[58]
   |    └(R)─ 70[54]
   |       └(L)─ 40[49]
   |            └(L)─ 30[32]
   └(R)─ 99[62]
      ├(L)─ 90[55]
      └(R)─ 102[3]
*/
    /*
Expected output Task 2
LST110	Language and study skills 110                                              6	1	Sem 1
WTW124	Mathematics 124                                                            16	1	Sem 2
UP0102	Academic orientation 102                                                   0	1	Year
WTW114	Calculus 114                                                               16	1	Sem 1
WTW123	Numerical analysis 123                                                     8	1	Sem 2
PHY114	First course in physics 114                                                16	1	Sem 1
PHY124	First course in physics 124                                                16	1	Sem 2
AIM102	Academic information management 102                                        6	1	Sem 2
COS122	Operating systems 122                                                      16	1	Sem 2
COS132	Imperative programming 132                                                 16	1	Sem 1
COS110	Program design: Introduction 110                                           16	1	Sem 2
COS151	Introduction to computer science 151                                       8	1	Sem 1
COS212	Data structures and algorithms 212                                         16	2	Sem 1
COS226	Concurrent systems 226                                                     16	2	Sem 2
COS284	Computer organisation and architecture 284                                 16	2	Sem 2
COS210	Theoretical computer science 210                                           8	2	Sem 1
WTW248	Vector analysis 248                                                        12	2	Sem 2
PHY255	Waves, thermodynamics and modem physics 255                                24	2	Sem 1
PHY263	General physics 263                                                        24	2	Sem 2
WTW211	Linear algebra 211                                                         12	2	Sem 1
WTW218	Calculus 218                                                               12	2	Sem 1
WTW220	Analysis 220                                                               12	2	Sem 2
COS314	Artificial intelligence 314                                                18	3	Sem 1
COS330	Computer security and ethics 330                                           18	3	Sem 2
COS333	Programming languages 333                                                  18	3	Sem 2
COS344	Computer graphics 344                                                      18	3	Sem 1
PHY310	Particle and astroparticle physics 310                                     18	3	Sem 2
PHY356	Electronics, electromagnetism and quantum mechanics 356                    36	3	Sem 1
PHY364	Statistical mechanics, solid state physics and modelling 364               36	3	Sem 2
COS711	Artificial Intelligence (II) 711                                           15	4	Sem 2
FSK700	Physics 700                                                                135	4	Year
Remove first Where Module Code is COS344
--------------
String returned: [COS344, Computer graphics 344, 18, 3, Sem 1]
COS110{10}[121]
├(L)─ AIM102{7}[72]
└(R)─ WTW220{21}[112]
   ├(L)─ COS333{24}[111]
   |    ├(L)─ COS226{13}[109]
   |    |    ├(L)─ COS210{15}[85]
   |    |    |    ├(L)─ COS151{11}[63]
   |    |    |    |    └(L)─ COS122{8}[52]
   |    |    |    |         └(R)─ COS132{9}[24]
   |    |    |    └(R)─ COS212{12}[76]
   |    |    └(R)─ COS330{23}[65]
   |    |       └(L)─ COS284{14}[34]
   |    |            └(R)─ COS314{22}[15]
   |    └(R)─ FSK700{30}[91]
   |       ├(L)─ COS711{29}[75]
   |       └(R)─ PHY356{27}[91]
   |          ├(L)─ PHY255{17}[76]
   |          |    ├(L)─ PHY124{6}[64]
   |          |    |    └(L)─ LST110{0}[61]
   |          |    |         └(R)─ PHY114{5}[35]
   |          |    └(R)─ PHY263{18}[64]
   |          |       └(R)─ PHY310{26}[10]
   |          └(R)─ PHY364{28}[89]
   |             └(R)─ WTW123{4}[81]
   |                ├(L)─ WTW114{3}[31]
   |                |    └(L)─ UP0102{2}[15]
   |                └(R)─ WTW218{20}[62]
   |                   └(L)─ WTW211{19}[29]
   |                        └(L)─ WTW124{1}[14]
   └(R)─ WTW248{16}[61]

Is treap valid after removing : COS344 ->Valid
Electronics, electromagnetism and quantum mechanics 356{27}[121]
├(L)─ Computer organisation and architecture 284{14}[118]
|    ├(L)─ Academic orientation 102{2}[91]
|    |    ├(L)─ Academic information management 102{7}[51]
|    |    └(R)─ Analysis 220{21}[88]
|    |       └(R)─ Calculus 114{3}[71]
|    |          ├(L)─ Artificial Intelligence (II) 711{29}[49]
|    |          |    └(R)─ Artificial intelligence 314{22}[24]
|    |          └(R)─ Calculus 218{20}[56]
|    └(R)─ Concurrent systems 226{13}[91]
|       ├(L)─ Computer security and ethics 330{23}[46]
|       └(R)─ Data structures and algorithms 212{12}[54]
└(R)─ Introduction to computer science 151{11}[117]
   ├(L)─ Imperative programming 132{9}[57]
   |    └(L)─ General physics 263{18}[55]
   |         └(L)─ First course in physics 124{6}[39]
   |              └(L)─ First course in physics 114{5}[4]
   └(R)─ Waves, thermodynamics and modem physics 255{17}[113]
      └(L)─ Theoretical computer science 210{15}[90]
           ├(L)─ Mathematics 124{1}[87]
           |    ├(L)─ Linear algebra 211{19}[61]
           |    |    └(L)─ Language and study skills 110{0}[57]
           |    └(R)─ Numerical analysis 123{4}[73]
           |       └(R)─ Operating systems 122{8}[58]
           |          └(R)─ Statistical mechanics, solid state physics and modelling 364{28}[55]
           |             └(L)─ Particle and astroparticle physics 310{26}[55]
           |                  └(R)─ Program design: Introduction 110{10}[48]
           |                     ├(L)─ Physics 700{30}[21]
           |                     └(R)─ Programming languages 333{24}[1]
           └(R)─ Vector analysis 248{16}[11]

Is treap valid after removing : COS344 ->Valid

COS344 deleted
--------------
Attempting to findAllWhere Session is Sem 1
[LST110, Language and study skills 110, 6, 1, Sem 1]
[WTW114, Calculus 114, 16, 1, Sem 1]
[PHY114, First course in physics 114, 16, 1, Sem 1]
[COS132, Imperative programming 132, 16, 1, Sem 1]
[COS151, Introduction to computer science 151, 8, 1, Sem 1]
[COS212, Data structures and algorithms 212, 16, 2, Sem 1]
[COS210, Theoretical computer science 210, 8, 2, Sem 1]
[PHY255, Waves, thermodynamics and modem physics 255, 24, 2, Sem 1]
[WTW211, Linear algebra 211, 12, 2, Sem 1]
[WTW218, Calculus 218, 12, 2, Sem 1]
[COS314, Artificial intelligence 314, 18, 3, Sem 1]
[PHY356, Electronics, electromagnetism and quantum mechanics 356, 36, 3, Sem 1]
Correct records found
--------------
Attempting to countOccurences of Session as Sem 1
countOccurences of Session as Sem 1-> 12
--------------
Attempting to countOccurences of Session as Sem 2
countOccurences of Session as Sem 2-> 16
--------------
Attempting to countOccurences of Module Code as WTW 211
countOccurences of Module Code as WTW211-> 1

*/
/* Expected output task 3
----------------
Database testing
----------------
Empty Database testing
Empty Database insert testing
incorrect row insert testing
Incorrect insert caught: Invalid number of columns
empty row insert testing
empty insert caught: Invalid number of columns
empty removeFirstWhere testing
empty removeFirstWhere with wrong column name
wrong column name removeFirstWhere caught: module code is not a valid column name in database
empty removeFirstWhere
empty removeFirstWhere returned
empty removeAllWhere testing
empty removeAllWhere with wrong column name
wrong column name removeAllWhere caught: session is not a valid column name in database
empty removeAllWhere
empty removeAllWhere returned
empty findFirstWhere testing
empty findFirstWhere with wrong column name
wrong column name findFirstWhere caught: session is not a valid column name in database
empty findFirstWhere
empty findFirstWhere returned
empty findAllWhere testing
empty findAllWhere with wrong column name
wrong column name findAllWhere caught: session is not a valid column name in database
empty findAllWhere
empty findAllWhere returned
empty updateFirstWhere testing
empty updateFirstWhere with wrong column name
wrong column name updateFirstWhere caught: session is not a valid column name in database
empty updateFirstWhere
empty updateFirstWhere returned
empty updateAllWhere testing
empty updateAllWhere with wrong column name
wrong column name updateAllWhere caught: session is not a valid column name in database
empty updateAllWhere
empty updateAllWhere returned
empty generateIndexOn testing
empty generateIndexOn with wrong column name
wrong column name generateIndexOn caught: session is not a valid column name in database
empty generateIndexOn
empty generateIndexOn returned
empty generateIndexAll testing
empty generateIndexAll
empty generateIndexAll returned
empty countOccurences testing
empty countOccurences with wrong column name
wrong column name countOccurences caught: session is not a valid column name in database
empty countOccurences
no countOccurences returned

------------
DB testing
------------

insert testing
------------
insert database full test
database full exception caught: Database is full
insert database test
database succesfully populated
insert database generateIndexOn test
insert database generateIndexOn incorrect name test
wrong column name generateIndexOn caught: session is not a valid column name in database
insert database generateIndexOn Normal test
Module Code index generated
UP0102{2}[123]
├(L)─ LST110{0}[15]
└(R)─ WTW114{3}[94]
   └(R)─ WTW123{4}[65]
      └(R)─ WTW124{1}[5]

Is treap valid after generating indexOn Module code: Valid
insert exception database generateIndexOn test
Duplicate exception caught: Duplicate insert of:WTW114
insert database generateAllOn Normal test
all indexes generated
UP0102{2}[123]
├(L)─ LST110{0}[15]
└(R)─ WTW114{3}[95]
   └(R)─ WTW123{4}[65]
      └(R)─ WTW124{1}[5]

Is treap valid after generateIndexAll: Valid
Mathematics 124{1}[78]
├(L)─ Calculus 114{3}[77]
|    ├(L)─ Academic orientation 102{2}[49]
|    └(R)─ Language and study skills 110{0}[54]
└(R)─ Numerical analysis 123{4}[22]

Is treap valid after generateIndexAll: Valid
---------------
Testing Find & Update
---------------
Attempting to findfirstWhere Session is Year: [UP0102, Academic orientation 102, Year]
[UP0102, Academic orientation 102, Year]
Correct record found
Attempting to findAllWhere Session is Sem 1: [LST110, Language and study skills 110, Sem 1], [WTW114, Calculus 114, Sem 1]
[LST110, Language and study skills 110, Sem 1]
[WTW114, Calculus 114, Sem 1]
Correct records found
Attempting to updatefirstWhere Session is Year to Sem 2: [UP0102, Academic orientation 102, Year] -> [UP0102, Academic orientation 102, Sem 2]
[UP0102, Academic orientation 102, Sem 2]
Correct record found
Attempting to UpdateAllWhere Session is Sem 1 to Year: [LST110, Language and study skills 110, Sem 1], [WTW114, Calculus 114, Sem 1] -> [LST110, Language and study skills 110, Year], [WTW114, Calculus 114, Year]
[LST110, Language and study skills 110, Year]
[WTW114, Calculus 114, Year]
Correct records updated
---------------
removing all modules
--------------
Removing: LST110
String returned: [LST110, Language and study skills 110, Year]
UP0102{2}[123]
└(R)─ WTW114{3}[95]
   └(R)─ WTW123{4}[65]
      └(R)─ WTW124{1}[5]

Is treap valid after removing : LST110->Valid
Mathematics 124{1}[78]
├(L)─ Calculus 114{3}[77]
|    └(L)─ Academic orientation 102{2}[49]
└(R)─ Numerical analysis 123{4}[22]

Is treap valid after removing : LST110->Valid

--------------
Removing: WTW124
String returned: [WTW124, Mathematics 124, Sem 2]
UP0102{2}[123]
└(R)─ WTW114{3}[95]
   └(R)─ WTW123{4}[65]

Is treap valid after removing : WTW124->Valid
Calculus 114{3}[77]
├(L)─ Academic orientation 102{2}[49]
└(R)─ Numerical analysis 123{4}[22]

Is treap valid after removing : WTW124->Valid

--------------
Removing: UP0102
String returned: [UP0102, Academic orientation 102, Sem 2]
WTW114{3}[95]
└(R)─ WTW123{4}[65]

Is treap valid after removing : UP0102->Valid
Calculus 114{3}[77]
└(R)─ Numerical analysis 123{4}[22]

Is treap valid after removing : UP0102->Valid

--------------
Removing: WTW114
String returned: [WTW114, Calculus 114, Year]
WTW123{4}[65]

Is treap valid after removing : WTW114->Valid
Numerical analysis 123{4}[22]

Is treap valid after removing : WTW114->Valid

--------------
Removing: WTW123
String returned: [WTW123, Numerical analysis 123, Sem 2]

Is treap valid after removing : WTW123->Valid

Is treap valid after removing : WTW123->Valid


 */